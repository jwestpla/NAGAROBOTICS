# Example code for IMRT100 robot project


# Import some modules that we need
import imrt_robot_serial
import signal
import time
import sys
import random

LEFT = -1
RIGHT = 1
FORWARDS = 1
BACKWARDS = -1
DRIVING_SPEED = 100
TURNING_SPEED = 100
STOP_DISTANCE = 25

def solve_maze():
    """
    	N
    W		E
    	S
    
    UP 	 	(N)	- maze.get_neighbours()[0][1]
    RIGHT 	(E)	- maze.get_neighbours()[1][2]
    DOWN 	(S) - maze.get_neighbours()[2][1]
    LEFT 	(W) - maze.get_neighbours()[1][0]
    
    """
    
    facing = "S"
    
    while maze.is_maze_solved() == False:
        
        left_wall = get_left_wall(facing)
        front_wall = get_front_wall(facing)
        
        if left_wall != 1:
            #facing = rotate_cw(facing)
            facing = rotate_facing(facing, "CCW")
            step_where_facing(facing)
            continue
        elif front_wall != 1:
            step_where_facing(facing)
            continue
        else:
            #facing = rotate_ccw(facing)
            facing = rotate_facing(facing, "CW")
            continue
    else:
        print ("GOTCHA")

		
def get_left_wall(facing):
    if facing == "N":
        return maze.get_neighbours()[1][0]
    elif facing == "E":
        return maze.get_neighbours()[0][1]
    elif facing == "S":
        return maze.get_neighbours()[1][2]
    elif facing == "W":
        return maze.get_neighbours()[2][1]
    
def get_front_wall(facing):
    if facing == "N":
        return maze.get_neighbours()[0][1]
    elif facing == "E":
        return maze.get_neighbours()[1][2]
    elif facing == "S":
        return maze.get_neighbours()[2][1]
    elif facing == "W":
        return maze.get_neighbours()[1][0]
    
def step_where_facing(facing):
    if facing == "N":
        maze.up()
    elif facing == "E":
        maze.right()
    elif facing == "S":
        maze.down()
    elif facing == "W":
        maze.left()
    
def rotate_facing(facing, rotation):

    directions = ["N", "E", "S", "W"]
    facindex = directions.index(facing)
    
    if rotation == "CW":
        if facindex == len(directions) - 1:
            return directions[0]
        else:
            return directions[facindex + 1]
        
    elif rotation == "CCW":
        if facindex == 0:
            return directions[-1]
        else:
            return directions[facindex - 1]

solve_maze()


# We want our program to send commands at 10 Hz (10 commands per second)
execution_frequency = 10 #Hz
execution_period = 1. / execution_frequency #seconds


# Create motor serial object
motor_serial = imrt_robot_serial.IMRTRobotSerial()


# Open serial port. Exit if serial port cannot be opened
try:
    motor_serial.connect("/dev/ttyACM0")
except:
    print("Could not open port. Is your robot connected?\nExiting program")
    sys.exit()

    
# Start serial receive thread
motor_serial.run()


# Now we will enter a loop that will keep looping until the program terminates
# The motor_serial object will inform us when it's time to exit the program
# (say if the program is terminated by the user)
print("Entering loop. Ctrl+c to terminate")
while not motor_serial.shutdown_now :


    ###############################################################
    # This is the start of our loop. Your code goes below.        #
    #                                                             #
    # An example is provided to give you a starting point         #
    # In this example we get the distance readings from each of   #
    # the two distance sensors. Then we multiply each reading     #
    # with a constant gain and use the two resulting numbers      #
    # as commands for each of the two motors.                     #
    #  ________________________________________________________   #
    # |                                                        |  #
    # V                                                           #
    # V                                                           #
    ###############################################################






    # Get and print readings from distance sensors
    dist_1 = motor_serial.get_dist_1()
    dist_2 = motor_serial.get_dist_2()
    print("Dist 1:", dist_1, "   Dist 2:", dist_2)

    # Check if there is an obstacle in the way
    if dist_1 < STOP_DISTANCE or dist_2 < STOP_DISTANCE:
        # There is an obstacle in front of the robot
        # First let's stop the robot for 1 second
        print("Obstacle!")
        stop_robot(1)

        # Reverse for 0.5 second
        drive_robot(BACKWARDS, 0.5)

        # Turn random angle
        turn_robot_random_angle()
        

    else:
        # If there is nothing in front of the robot it continus driving forwards
        drive_robot(FORWARDS, 0.1)


        
                



    ###############################################################
    #                                                           A #
    #                                                           A #
    # |_________________________________________________________| #
    #                                                             #
    # This is the end of our loop,                                #
    # execution continus at the start of our loop                 #
    ###############################################################
    ###############################################################





# motor_serial has told us that its time to exit
# we have now exited the loop
# It's only polite to say goodbye
print("Goodbye")
